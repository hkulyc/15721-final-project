# this file contains C++ code templates for passing queries to DuckDB to handle
macro: |-
    #include <stdexcept>
    #include <vector>
    #include "duckdb.hpp"

    duckdb::DuckDB db(nullptr);
    thread_local duckdb::Connection trans_con({db_name});

global: |-
    thread_local std::unique_ptr<duckdb::PreparedStatement> {function_name}_prepare = trans_con.Prepare("{prep_statement}");

function_arg: |-
    const std::vector<duckdb::Value> &values{0}, std::vector<duckdb::Value> *valid_mask{0}, std::vector<duckdb::Value> *return_mask{0}, std::vector<duckdb::Value> *loop_mask{0}

prepare_input: |-
    for(int i=0;i<{vector_size};i++){{
        int j = {arg} * {vector_size} + i;
        if(valid_mask{arg}->at(j) == 0 || (return_mask{arg} != NULL && return_mask{arg}->at(j) == 0) || (loop_mask{arg} != NULL && loop_mask{arg}->at(j) == 0))
            input[j] = duckdb::Value();
        else
            input[j] = values{arg}[j];
    }}
  
function: |-
    std::vector<duckdb::Value> {function_name}({function_args}){{
        // prepare ps input
        std::vector<duckdb::Value> input({input_size});
    {prepare_input}
        // execute and fetch result
        auto res = {function_name}_prepare->Execute(input);
        if(res->HasError()){{
            throw std::runtime_error("Error when waiting for query result.");
            return;
        }}
        auto data = res->Fetch();
        // prepare result
        std::vector<duckdb::Value> ret({vector_size});
        for (idx_t i = 0; i < {vector_size}; i++) {{
            ret[i] = data->GetValue(0, i);
        }}
        return ret;
    }}

function_call: |-
    {function_name}({prepare_args})